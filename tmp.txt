const TableView_Mod = () => {
  // ... existing state declarations ...
  
+  // Create a ref to always have the latest editedData
+  const editedDataRef = useRef(editedData);
+  
+  // Update the ref whenever editedData changes
+  useEffect(() => {
+    editedDataRef.current = editedData;
+  }, [editedData]);
+
+  // Alternative solution: Use a callback that gets the current state
+  const handleInputChange = useCallback((columnKey, newValue) => {
+    setEditedData((prev) => ({
+      ...prev,
+      [columnKey]: newValue,
+    }));
+  }, []);

  // ... existing useEffect and other code ...

-  const renderCell = (column: any, row: any) => {
+  const renderCell = useCallback((column: any, row: any) => {
    const hasEditAccess = canEditStudy(row, researcherId)
    console.log("hasEditAccess", hasEditAccess)
    const columnKey = column.id
    const value = column.value(row)
    
    if (columnKey === "isShared") {
      return (
        <div>
          {row.isShared ? (
            <span className="p-tag p-tag-info p-tag-rounded">
              {`${getparent(row.parent)}(${getAccessLevelLabel(getResearcherAccessLevel(row, researcherId))})`}
            </span>
          ) : (
            "Owner"
          )}
        </div>
      )
    }
    
    // Check if this cell should be editable
    const isEditable =
      editableColumns.includes(columnKey) &&
      activeButton.action === "edit" &&
      activeButton.id === row.id &&
      hasEditAccess

    if (!isEditable) {
      return <div>{formatValue(value, columnKey)}</div>
    }

    const fieldConfig = fieldConfigs[columnKey]
+    // Use the ref to get the current editedData
+    const currentEditedData = editedDataRef.current;

    if (fieldConfig?.type === "select") {
      return (
        <Dropdown
-          value={editedData[columnKey] ?? value}
+          value={currentEditedData[columnKey] ?? value}
          onChange={(e) => {
-            setEditedData((prev) => ({
-              ...prev,
-              [columnKey]: e.value,
-            }))
+            handlenputChange(columnKey, e.value);
          }}
          options={fieldConfig.options}
          optionLabel="label"
          optionValue="value"
          className="w-full"
        />
      )
    }

    if (fieldConfig?.type === "multiline") {
      return (
        <InputTextarea
          rows={2}
-          value={editedData[columnKey] ?? value}
+          value={currentEditedData[columnKey] ?? value}
          onChange={(e) => {
-            setEditedData((prev) => ({
-              ...prev,
-              [columnKey]: e.target.value,
-            }))
+            handleInputChange(columnKey, e.target.value);
          }}
          className="w-full"
        />
      )
    }

    return (
      <InputText
-        value={editedData[columnKey] ?? value}
+        value={currentEditedData[columnKey] ?? value}
        onChange={(e) => {
-          console.log("InputText changed", e.target.value, columnKey, "editedData:", editedData, "value:", value)
-          setEditedData((prev) => ({
-            ...prev,
-            [columnKey]: e.target.value,
-          }))
+          console.log("InputText changed", e.target.value, columnKey, "editedData:", currentEditedData, "value:", value)
+          handleInputChange(columnKey, e.target.value);
        }}
        className="w-full"
      />
    )
-  }
+  }, [activeButton, researcherId, editableColumns, fieldConfigs, handleInputChange])

  // ... rest of the component code ...
}I