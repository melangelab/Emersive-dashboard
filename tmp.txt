// Option 1: Use a single state update with useCallback
const handleEditActivityTable = useCallback((activity) => {
  console.warn("Editing activity in table:", activity?.id, editingActivity?.id, rowMode, activeButton);
  if (!canEditActivity(activity, studies, researcherId, props.sharedstudies)) {
    enqueueSnackbar(t("You don't have permission to edit this activity"), { variant: "error" });
    return;
  }
  
  if (editingActivity?.id === activity.id) {
    // Cancel edit mode - update all states together
    setRowMode("view");
    setEditingActivity(null);
    setEditedValues({});
    setActiveButton({ id: null, action: null });
  } else {
    // Start editing - update all states together
    setRowMode("edit");
    setEditingActivity(activity);
    setEditedValues({
      name: activity.name,
      groups: activity.groups || []
    });
    setActiveButton({ id: activity.id, action: "edit" });
  }
  console.warn("Now Editing activity in table:", activity?.id, editingActivity?.id, rowMode, activeButton);
}, [editingActivity, rowMode, activeButton, studies, researcherId, props.sharedstudies]);

// Option 2: Use a single state object to avoid race conditions
const [editState, setEditState] = useState({
  mode: "view",
  editingActivity: null,
  editedValues: {},
  activeButton: { id: null, action: null }
});

const handleEditActivityTable = useCallback((activity) => {
  console.warn("Editing activity in table:", activity?.id, editState.editingActivity?.id, editState.mode, editState.activeButton);
  
  if (!canEditActivity(activity, studies, researcherId, props.sharedstudies)) {
    enqueueSnackbar(t("You don't have permission to edit this activity"), { variant: "error" });
    return;
  }
  
  if (editState.editingActivity?.id === activity.id) {
    // Cancel edit mode
    setEditState({
      mode: "view",
      editingActivity: null,
      editedValues: {},
      activeButton: { id: null, action: null }
    });
  } else {
    // Start editing
    setEditState({
      mode: "edit",
      editingActivity: activity,
      editedValues: {
        name: activity.name,
        groups: activity.groups || []
      },
      activeButton: { id: activity.id, action: "edit" }
    });
  }
}, [editState, studies, researcherId, props.sharedstudies]);

// Option 3: Use functional state updates to ensure consistency
const handleEditActivityTable = useCallback((activity) => {
  console.warn("Editing activity in table:", activity?.id);
  
  if (!canEditActivity(activity, studies, researcherId, props.sharedstudies)) {
    enqueueSnackbar(t("You don't have permission to edit this activity"), { variant: "error" });
    return;
  }
  
  // Use functional updates to ensure we're working with the latest state
  setEditingActivity(prevEditingActivity => {
    if (prevEditingActivity?.id === activity.id) {
      // Cancel edit mode
      setRowMode("view");
      setEditedValues({});
      setActiveButton({ id: null, action: null });
      return null;
    } else {
      // Start editing
      setRowMode("edit");
      setEditedValues({
        name: activity.name,
        groups: activity.groups || []
      });
      setActiveButton({ id: activity.id, action: "edit" });
      return activity;
    }
  });
}, [studies, researcherId, props.sharedstudies]);

// Update your renderCell function to use the single state (if using Option 2)
renderCell: (activity) => {
  if (editState.mode === "edit" && editState.editingActivity?.id === activity.id) {
    return (
      <TextField
        value={editState.editedValues.name ?? activity.name}
        onChange={(e) => handleCellValueChange(activity.id, 'name', e.target.value)}
        fullWidth
        size="small"
        variant="outlined"
        className={classes.editableField}
      />
    );
  }
  console.warn("rendercell inside activity list", activity.name, " Mode : " + editState.mode + " Editing Activity: " + editState.editingActivity?.id);
  return activity.name;
}