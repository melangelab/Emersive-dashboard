// Changes needed in the ActivityList component

// 1. Add a new state variable to store the full combined activities list
const [combinedActivities, setCombinedActivities] = useState([])

// 2. Update the searchActivities function to store the full combined list
const searchActivities = async (searchVal?: string) => {
  const searchTxt = searchVal ?? search
  const selectedstudiesData = selected?.filter((o) => studies?.some(({ name }) => o === name)) || []
  const selectedsharedData = props.sharedstudies
    ? selected.filter((o) => props.sharedstudies?.some(({ name }) => o === name))
    : []
  const selectedData = [...selectedstudiesData, ...selectedsharedData]
  
  if (selectedData.length > 0) {
    setLoading(true)
    try {
      const activitiesData = await Service.getAll("activities")
      setAllActivities(activitiesData)
      console.log("activitiesData", activitiesData)
      const resylt = Array.isArray(activitiesData) ? activitiesData : []
      const ids = resylt.map((activity) => activity.id)
      const detailedActivities = await Promise.all(
        ids.map((id) => Service.getDataByKey("activities", [id], "id").then((data) => data[0]))
      )
      console.log("Detailed Activities:", detailedActivities)

      let filteredData = activitiesData || []
      if (filterParam) {
        filteredData = filteredData.filter((factivity) => factivity.id === filterParam)
      } else if (!!searchTxt && searchTxt.trim?.().length > 0) {
        filteredData = filteredData.filter(
          (factivity) =>
            factivity.name?.toLowerCase().includes(searchTxt?.toLowerCase?.()) ||
            factivity.id?.toLowerCase().includes(searchTxt?.toLowerCase?.())
        )
      }
      const sortedData = sortData(filteredData, selectedData, "name")
      setActivities(sortedData)
      
      const fetchedCommunityActivities = await fetchCommunityActivities()
      const filteredCommunityActivities = fetchedCommunityActivities.filter(
        (activity) =>
          !searchTxt ||
          activity.name?.toLowerCase().includes(searchTxt?.toLowerCase?.()) ||
          activity.id?.toLowerCase().includes(searchTxt?.toLowerCase?.())
      )
      
      // Create the combined activities list
      const combinedActivitiesList = [...sortedData, ...filteredCommunityActivities]
      setCombinedActivities(combinedActivitiesList)
      
      // Set paginated activities from the combined list
      setPaginatedActivities(combinedActivitiesList.slice(page * rowCount, page * rowCount + rowCount))
      console.log(
        "setPaginatedActivities",
        combinedActivitiesList,
        combinedActivitiesList.slice(page * rowCount, page * rowCount + rowCount)
      )
    } catch (error) {
      console.error("Error searching activities:", error)
      enqueueSnackbar(t("Failed to search activities"), { variant: "error" })
    } finally {
      setLoading(false)
    }
  } else {
    setActivities([])
    setPaginatedActivities([])
    setCombinedActivities([])
    setLoading(false)
  }
  setSelectedActivities([])
  setLoading(false)
}

// 3. Update the handleChangePage function to use combinedActivities
const handleChangePage = (page: number, rowCount: number) => {
  setLoading(true)
  setRowCount(rowCount)
  setPage(page)
  localStorage.setItem("activities", JSON.stringify({ page: page, rowCount: rowCount }))
  
  const selectedstudiesData = selected?.filter((o) => studies?.some(({ name }) => o === name)) || []
  const selectedsharedData = props.sharedstudies
    ? selected.filter((o) => props.sharedstudies?.some(({ name }) => o === name))
    : []
  const selectedData = [...selectedstudiesData, ...selectedsharedData]

  // Use the stored combinedActivities instead of recreating it
  setPaginatedActivities(
    sortData(combinedActivities, selectedData, "name").slice(page * rowCount, page * rowCount + rowCount)
  )
  setLoading(false)
}

// 4. Update the originalIndexMap to use combinedActivities
const originalIndexMap = useMemo(() => {
  return combinedActivities.reduce((acc, activity, index) => {
    acc[activity.id] = index;
    return acc;
  }, {});
}, [combinedActivities]);

// 5. Update the navigation functions in the viewingActivity section
const handlePrevious = () => {
  const currentIndex = combinedActivities.findIndex((a) => a.id === viewingActivity.id)
  if (currentIndex > 0) {
    setViewingActivity(combinedActivities[currentIndex - 1])
  }
}

const handleNext = () => {
  const currentIndex = combinedActivities.findIndex((a) => a.id === viewingActivity.id)
  if (currentIndex < combinedActivities.length - 1) {
    setViewingActivity(combinedActivities[currentIndex + 1])
  }
}

// 6. Update the CommonTable data prop to use combinedActivities
<CommonTable
  data={combinedActivities}
  columns={columns}
  actions={activityActions}
  indexmap={originalIndexMap}
  sortConfig={sortConfig}
  onSort={(field) => {
    setSortConfig({
      field,
      direction: sortConfig.field === field && sortConfig.direction === "asc" ? "desc" : "asc",
    });
  }}
  categorizeItems={categorizeActivities}
  showCategoryHeaders={true}
  filters={filters}
  onFilter={(newFilters) => setFilters(newFilters)}
  filterDisplay="row"
  key={editingActivity ?`${editingActivity.id}` : null}
/>

// 7. Update the Pagination component to use combinedActivities
<Pagination
  data={combinedActivities}
  updatePage={handleChangePage}
  rowPerPage={[20, 40, 60, 80]}
  currentPage={page}
  currentRowCount={rowCount}
/>

// 8. Update the no records condition
{!!combinedActivities && combinedActivities.length > 0 ? (
  // ... existing grid content
) : (
  <Box className={classes.norecordsmain}>
    <Box display="flex" p={2} alignItems="center" className={classes.norecords}>
      <Icon>info</Icon>
      {`${t("No Records Found")}`}
    </Box>
  </Box>
)}

// 9. Remove the allActivitiesForDisplay variable since it's no longer needed
// const allActivitiesForDisplay = [...paginatedActivities, ...communityActivities]