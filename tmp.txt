import React, { useState, useEffect, useRef } from "react"
import {
  Typography,
  makeStyles,
  Theme,
  createStyles,
  Box,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Paper,
  Chip,
  Button,
  Grid,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  TextField,
  Tabs,
  Tab,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  List,
  FormControlLabel,
  Switch,
  Divider,
  CircularProgress,
} from "@material-ui/core"
import { useTranslation } from "react-i18next"
import { useSnackbar } from "notistack"
import LAMP from "lamp-core"
import { Service } from "../../DBService/DBService"
import ViewItems, { FieldConfig } from "../SensorsList/ViewItems"
import { VideocamOutlined, AudiotrackOutlined, DescriptionOutlined, GetApp } from "@material-ui/icons"
import { Mic, MicOff, Stop } from "@material-ui/icons"
import CloseIcon from "@material-ui/icons/Close"
import { ImageUploader } from "../../ImageUploader"
import { useStyles as ViewItemsStyles } from "../SensorsList/ViewItems"
import { SchemaList } from "./ActivityMethods"
import DynamicForm from "../../shared/DynamicForm"
import FormBuilder from "./FormBuilder"
import MoodTrackerBuilder from "./MoodTrackerBuilder"

const useStyles = makeStyles((theme: Theme) =>
  createStyles({
    tableContainer: {
      maxHeight: "300px",
      overflow: "auto",
      border: "1px solid rgba(224, 224, 224, 1)",
      borderRadius: 4,
    },
    table: {
      minWidth: 300,
    },
    tableCell: {
      fontSize: "0.875rem",
      padding: "8px 16px",
    },
    tableHeader: {
      fontWeight: 600,
      backgroundColor: "#f5f5f5",
    },
    codeBlock: {
      maxHeight: "300px",
      overflow: "auto",
      marginTop: theme.spacing(1),
      padding: theme.spacing(2),
      backgroundColor: "#f5f5f5",
      borderRadius: 4,
      fontFamily: "monospace",
      fontSize: "0.875rem",
    },
    viewDivider: {
      margin: "8px 0",
    },
    developerInfoContainer: {
      marginTop: theme.spacing(1),
    },
    developerInfoItem: {
      marginBottom: theme.spacing(1.5),
    },
    infoLabel: {
      fontWeight: 600,
      display: "inline-block",
      width: "80px",
      fontSize: "0.875rem",
    },
    infoValue: {
      display: "inline-block",
      fontSize: "0.875rem",
    },
    rootContainer: {
      height: "100%",
      width: "100%",
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
    },
    chip: {
      margin: theme.spacing(0.5),
    },
    videoPreview: {
      width: "100%",
      borderRadius: theme.shape.borderRadius,
      overflow: "hidden",
      marginTop: theme.spacing(2),
    },
    audioPreview: {
      width: "100%",
      marginTop: theme.spacing(2),
      padding: theme.spacing(2),
      backgroundColor: "#f5f5f5",
      borderRadius: theme.shape.borderRadius,
    },
    mediaControls: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      marginTop: theme.spacing(1),
    },
    previewDialog: {
      "& .MuiDialog-paper": {
        maxWidth: "90vw",
        maxHeight: "90vh",
      },
    },
    previewVideo: {
      width: "100%",
      maxHeight: "70vh",
    },
    scoreRange: {
      padding: theme.spacing(1),
      marginBottom: theme.spacing(1),
      borderRadius: theme.shape.borderRadius,
      backgroundColor: "#f5f5f5",
    },
    rangeItem: {
      display: "flex",
      justifyContent: "space-between",
      padding: theme.spacing(1),
      borderBottom: "1px solid #e0e0e0",
      "&:last-child": {
        borderBottom: "none",
      },
    },
    scheduleItem: {
      padding: theme.spacing(1),
      marginBottom: theme.spacing(1),
      borderRadius: theme.shape.borderRadius,
      backgroundColor: "#f5f5f5",
    },
    videoContainer: {
      display: "flex",
      flexDirection: "column",
      gap: theme.spacing(3),
      justifyContent: "center",
    },
    videoPreviewBox: {
      justifyItems: "center",
      width: "90%",
      aspectRatio: "20/9",
      backgroundColor: "#1a237e", // Dark blue background
      borderRadius: theme.spacing(2),
      position: "relative",
      overflow: "hidden",
      marginBottom: theme.spacing(3),
    },
    timer: {
      position: "absolute",
      top: theme.spacing(2),
      left: "50%",
      transform: "translateX(-50%)",
      color: "#fff",
      fontSize: "2rem",
      fontWeight: "bold",
    },
    previewThumbnail: {
      width: 80,
      height: 80,
      borderRadius: theme.spacing(1),
      overflow: "hidden",
      "& video": {
        width: "100%",
        height: "100%",
        objectFit: "cover",
      },
    },
    videoFeed: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
    },
    controlsContainer: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gap: theme.spacing(4),
      padding: theme.spacing(2),
    },
  })
)

export interface DeveloperInfo {
  version?: string
  versionNumber?: string
  userIp?: string
  sourceUrl?: string
  browser?: string
  device?: string
  user?: string
  status?: string
  submittedOn?: string
}

export const fetchUserIp = async () => {
  try {
    const response = await fetch("https://api64.ipify.org?format=json")
    const data = await response.json()
    return data.ip
  } catch (error) {
    console.error("Error fetching IP:", error)
    return "Unavailable"
  }
}

interface ActivityDetailItemProps {
  activity: any
  isEditing: boolean
  onSave: (updatedActivity: any) => void
  studies: Array<any>
  triggerSave?: boolean
}

const ActivityDetailItem: React.FC<ActivityDetailItemProps> = ({
  activity,
  isEditing,
  onSave,
  studies,
  triggerSave,
}) => {
  const classes = useStyles()
  const Viewitemsclasses = ViewItemsStyles()
  const { t } = useTranslation()
  const { enqueueSnackbar } = useSnackbar()
  const [loading, setLoading] = useState(false)
  const [previewDialogOpen, setPreviewDialogOpen] = useState(false)
  const [selectedMedia, setSelectedMedia] = useState<{
    type: "video" | "audio"
    src: string
    mimeType: string
  } | null>(null)
  const [schemaListObj, setSchemaListObj] = useState({})
  // Add state for developer info editing
  const [isDeveloperInfoEditing, setIsDeveloperInfoEditing] = useState(false)

  // Additional state variables for scoreInterpretation and ActivityGuideContent
  const [guideTab, setGuideTab] = useState(0)
  const [scoreSection, setScoreSection] = useState("")
  // const videoInputRef = useRef<HTMLInputElement>(null)
  // const audioInputRef = useRef<HTMLInputElement>(null)
  // const [stream, setStream] = useState<MediaStream | null>(null)
  // const [recording, setRecording] = useState(false)
  // const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null)
  // const [recordedChunks, setRecordedChunks] = useState<Blob[]>([])
  // const [recordingTime, setRecordingTime] = useState(0)
  // const [audioEnabled, setAudioEnabled] = useState(true)
  // const videoRef = useRef<HTMLVideoElement>(null)
  // const previewRef = useRef<HTMLVideoElement>(null)
  // const [audioStream, setAudioStream] = useState<MediaStream | null>(null)
  // const [audioRecording, setAudioRecording] = useState(false)
  // const [audioRecorder, setAudioRecorder] = useState<MediaRecorder | null>(null)
  // const [audioChunks, setAudioChunks] = useState<Blob[]>([])
  // const [audioRecordingTime, setAudioRecordingTime] = useState(0)
  // const audioRef = useRef<HTMLAudioElement>(null)
  // const audioPreviewRef = useRef<HTMLAudioElement>(null)
  // Add new range for score interpretation
  const [newRange, setNewRange] = useState({
    min: 0,
    max: 0,
    interpretation: "",
    severity: "low",
  })
  // const [activityImage, setActivityImage] = useState<string | null>(null);
  // const [selectedStudy, setSelectedStudy] = useState("");
  // const [selectedGroups, setSelectedGroups] = useState<string[]>([]);
  // const [showInFeed, setShowInFeed] = useState(true);
  // const [streakSettings, setStreakSettings] = useState({
  //   enabled: false,
  //   title: "",
  //   description: ""
  // });
  const [activityImage, setActivityImage] = useState(activity?.photo || null)
  const [activityDesc, setActivityDesc] = useState(activity?.description || null)
  const [selectedStudy, setSelectedStudy] = useState(activity?.study_id || "")
  const [selectedGroups, setSelectedGroups] = useState(activity?.groups || [])
  const [showInFeed, setShowInFeed] = useState(activity?.showInFeed ?? true)
  const [streakSettings, setStreakSettings] = useState({
    enabled: activity?.streak?.enabled ?? false,
    title: activity?.streak?.title || "",
    description: activity?.streak?.description || "",
  })

  // Form state
  const [editedValues, setEditedValues] = useState<{
    name: string
    description: string
    spec: string
    settings: any
    activityGuide: any
    category: string[]
    study: string
    groups: string[]
    image: string | null
    schedule: any[]
    formula4Fields: any
    scoreInterpretation: any
    developer_info?: {
      version?: string
      versionNumber?: string
      userIp?: string
      sourceUrl?: string
      browser?: string
      device?: string
      user?: string
      status?: string
      submittedOn?: string
    }
  }>({
    name: "",
    description: "",
    spec: "",
    settings: {},
    activityGuide: {},
    category: [],
    study: "",
    groups: [],
    image: null,
    schedule: [],
    scoreInterpretation: {},
    developer_info: {},
    formula4Fields: null,
  })
  console.log("Received activity", activity, isEditing, onSave, studies, triggerSave)
  LAMP.Activity.view(activity.id).then((res) => {
    console.log("Activity view response", res)
  })
  const [creatorName, setcreatorName] = useState(activity?.creator || "")
  useEffect(() => {
    const fetchname = async () => {
      const res = await LAMP.Researcher.view(activity?.creator)
      if (res) {
        setcreatorName(res.name)
      }
    }
    fetchname()
  }, [activity])

  const handleVideoUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (file) {
      const reader = new FileReader()
      reader.onloadend = () => {
        const mimeType = file.type || "video/webm"
        const dataUrl = reader.result as string

        const updatedActivityGuide = {
          ...editedValues.activityGuide,
          video: {
            data: dataUrl.startsWith("data:") ? dataUrl : `data:${mimeType}base64,${dataUrl.split(",")[1]}`,
            fileType: mimeType.split("/")[1],
            uploadedAt: new Date(),
          },
        }

        setEditedValues((prev) => ({
          ...prev,
          activityGuide: updatedActivityGuide,
        }))
      }
      reader.readAsDataURL(file)
    }
  }

  const handleAudioUpload_old = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (file) {
      const reader = new FileReader()
      reader.onloadend = () => {
        const mimeType = file.type || "audio/webm"
        const dataUrl = reader.result as string

        const updatedActivityGuide = {
          ...editedValues.activityGuide,
          audio: {
            data: dataUrl.startsWith("data:") ? dataUrl : `data:${mimeType}base64,${dataUrl.split(",")[1]}`,
            fileType: mimeType.split("/")[1],
            uploadedAt: new Date(),
          },
        }

        setEditedValues((prev) => ({
          ...prev,
          activityGuide: updatedActivityGuide,
        }))
      }
      reader.readAsDataURL(file)
    }
  }

  // Score interpretation methods
  const addScoreRange = () => {
    if (!scoreSection) {
      enqueueSnackbar("Please select a score section", { variant: "error" })
      return
    }

    const currentScoring = editedValues.scoreInterpretation || {}
    const currentSection = currentScoring[scoreSection] || {
      type: "numeric",
      ranges: [],
    }

    currentSection.ranges.push(newRange)

    setEditedValues((prev) => ({
      ...prev,
      scoreInterpretation: {
        ...currentScoring,
        [scoreSection]: currentSection,
      },
    }))

    setNewRange({
      min: 0,
      max: 0,
      interpretation: "",
      severity: "low",
    })
  }

  useEffect(() => {
    setSchemaListObj(SchemaList())
  }, [])
  useEffect(() => {
    const initializeData = async () => {
      if (!activity?.id) return

      try {
        setSelectedStudy(activity.study_id)
        setSelectedGroups(activity.groups || [])
        let developer_info = null
        const devRes = (await LAMP.Type.getAttachment(activity.id, "emersive.activity.developer_info")) as any
        if (devRes.error == undefined && devRes.data) {
          developer_info = Array.isArray(devRes.data) ? devRes.data[0] : devRes.data
        }
        console.log("devRes", devRes, developer_info)

        let activity_description = activity?.description
        let activity_image = activity?.photo
        let activity_streak = {
          enabled: false,
          title: "",
          description: "",
        }
        let activity_showInFeed = true

        const detailsRes = (await LAMP.Type.getAttachment(activity.id, "emersive.activity.details")) as any
        if (detailsRes.data) {
          const attachmentData = Array.isArray(detailsRes.data) ? detailsRes.data[0] : detailsRes.data
          activity_description = attachmentData.description || activity_description
          activity_image = attachmentData.photo || activity_image
          activity_streak = attachmentData.streak || activity_streak
          activity_showInFeed = attachmentData.showInFeed ?? activity_showInFeed
        }
        console.log("detailsRes", detailsRes, activity_description, activity_image)

        // Set all states at once after getting all data
        setActivityDesc(activity_description)
        setActivityImage(activity_image)
        setStreakSettings(activity_streak)
        setShowInFeed(activity_showInFeed)

        // Set edited values with all fetched data
        setEditedValues({
          name: activity?.name || "",
          description: activity_description || "",
          spec: activity?.spec || "",
          study: activity.study_id || "",
          groups: activity.groups || [],
          image: activity_image,
          settings: activity?.settings || {},
          activityGuide: activity?.activityGuide || {},
          category: activity?.category || [],
          schedule: activity?.schedule || [],
          scoreInterpretation: activity?.scoreInterpretation || {},
          developer_info: developer_info || {},
          formula4Fields: activity?.formula4Fields || "",
        })
      } catch (error) {
        console.error("Error initializing activity data:", error)
        // Set default values in case of error
        setEditedValues({
          name: activity?.name || "",
          description: activity?.description || "",
          spec: activity?.spec || "",
          study: activity.study_id || "",
          groups: activity.groups || [],
          image: activity?.photo || null,
          settings: activity?.settings || {},
          activityGuide: activity?.activityGuide || {},
          category: activity?.category || [],
          schedule: activity?.schedule || [],
          scoreInterpretation: activity?.scoreInterpretation || {},
          developer_info: {},
          formula4Fields: activity?.formula4Fields || "",
        })
      }
    }

    initializeData()
  }, [activity])

  useEffect(() => {
    if (triggerSave && isEditing) {
      handleSave()
    }
  }, [triggerSave])

  const handleSaveDeveloperInfo = async () => {
    setLoading(true)
    try {
      const currentDate = new Date().toISOString()
      const userip = await fetchUserIp()
      console.log("userip", userip)
      const developerInfo = {
        ...editedValues.developer_info,
        userIp: userip, // Default
        browser: navigator.userAgent
          ? navigator.userAgent.match(/chrome|firefox|safari|edge|opera/i)?.[0] || "Chrome"
          : "Chrome",
        device:
          navigator.userAgent && /windows/i.test(navigator.userAgent)
            ? "Windows"
            : navigator.userAgent && /mac/i.test(navigator.userAgent)
            ? "Mac OS"
            : navigator.userAgent && /android/i.test(navigator.userAgent)
            ? "Android"
            : navigator.userAgent && /iphone|ipad/i.test(navigator.userAgent)
            ? "iOS"
            : "Windows",
        submittedOn: `${new Date().getFullYear()}-${String(new Date().getMonth() + 1).padStart(2, "0")}-${String(
          new Date().getDate()
        ).padStart(2, "0")} ${String(new Date().getHours()).padStart(2, "0")}:${String(
          new Date().getMinutes()
        ).padStart(2, "0")}:${String(new Date().getSeconds()).padStart(2, "0")}`,
      }

      await LAMP.Type.setAttachment(activity.id, "me", "emersive.activity.developer_info", {
        developer_info: developerInfo,
      })

      await Service.updateMultipleKeys(
        "activities",
        {
          activities: [
            {
              id: activity.id,
              developer_info: developerInfo,
            },
          ],
        },
        ["developer_info"],
        "id"
      )

      setEditedValues((prev) => ({
        ...prev,
        developer_info: developerInfo,
      }))

      enqueueSnackbar(t("Successfully updated developer info."), {
        variant: "success",
      })

      setIsDeveloperInfoEditing(false)
    } catch (error) {
      console.error("Error updating developer info:", error)
      enqueueSnackbar(t("An error occurred while updating the developer info."), {
        variant: "error",
      })
    } finally {
      setLoading(false)
    }
  }

  const handleChangeStatus = async (newStatus) => {
    setLoading(true)
    try {
      const developerInfo = {
        ...editedValues.developer_info,
        status: newStatus || "Read",
      }

      await LAMP.Type.setAttachment(activity.id, "me", "emersive.activity.developer_info", {
        developer_info: developerInfo,
      })

      await Service.updateMultipleKeys(
        "activities",
        {
          activities: [
            {
              id: activity.id,
              developer_info: developerInfo,
            },
          ],
        },
        ["developer_info"],
        "id"
      )

      setEditedValues((prev) => ({
        ...prev,
        developer_info: developerInfo,
      }))

      enqueueSnackbar(t("Status updated successfully."), {
        variant: "success",
      })
    } catch (error) {
      console.error("Error updating status:", error)
      enqueueSnackbar(t("An error occurred while updating the status."), {
        variant: "error",
      })
    } finally {
      setLoading(false)
    }
  }

  const handleSave = async () => {
    setLoading(true)
    try {
      const updateData = {
        name: editedValues.name?.trim(),
        spec: editedValues.spec,
        settings: editedValues.settings,
        activityGuide: editedValues.activityGuide,
        category: editedValues.category,
        groups: editedValues.groups,
        scoreInterpretation: editedValues.scoreInterpretation,
        photo: editedValues.image,
        showFeed: showInFeed,
        streak: streakSettings,
        formula4Fields: editedValues.formula4Fields,
      }
      // TODO Add more fields for updates
      const result = await LAMP.Activity.update(activity.id, updateData as any)
      await LAMP.Type.setAttachment(activity.id, "me", "emersive.activity.developer_info", {
        developer_info: editedValues.developer_info,
      })
      await LAMP.Type.setAttachment(activity.id, "me", "emersive.activity.details", {
        description: editedValues.description,
        photo: editedValues.image,
        streak: streakSettings,
        showFeed: showInFeed,
      })
      console.log("save handler", updateData, editedValues)
      // Update in local DB
      await Service.updateMultipleKeys(
        "activities",
        {
          activities: [
            {
              id: activity.id,
              ...updateData,
            },
          ],
        },
        Object.keys(updateData),
        "id"
      )

      enqueueSnackbar(t("Successfully updated activity."), {
        variant: "success",
      })

      onSave({
        ...activity,
        ...updateData,
      })
    } catch (error) {
      console.error("Error updating activity:", error)
      enqueueSnackbar(t("An error occurred while updating the activity."), {
        variant: "error",
      })
    } finally {
      setLoading(false)
    }
  }

  const handleViewMedia = (type: "video" | "audio", src: string, mimeType: string) => {
    setSelectedMedia({
      type,
      src,
      mimeType,
    })
    setPreviewDialogOpen(true)
  }

  const getVideoMimeType = (fileType: string | undefined): string => {
    if (!fileType) return "video/mp4" // Default
    if (fileType.startsWith("video/")) return fileType
    const mimeTypeMap: { [key: string]: string } = {
      webm: "video/webm",
      mp4: "video/mp4",
      mov: "video/quicktime",
      avi: "video/x-msvideo",
      m4v: "video/mp4",
      mkv: "video/x-matroska",
    }
    return mimeTypeMap[fileType.toLowerCase()] || `video/${fileType}`
  }

  const getAudioMimeType = (fileType: string | undefined): string => {
    if (!fileType) return "audio/mpeg"
    if (fileType.startsWith("audio/")) return fileType
    const mimeTypeMap: { [key: string]: string } = {
      mp3: "audio/mpeg",
      wav: "audio/wav",
      ogg: "audio/ogg",
      aac: "audio/aac",
      m4a: "audio/mp4",
      flac: "audio/flac",
      webm: "audio/webm",
    }
    return mimeTypeMap[fileType.toLowerCase()] || `audio/${fileType}`
  }

  // Define fields for the ViewItems component
  const fields: FieldConfig[] = [
    {
      id: "name",
      label: t("Name"),
      value: activity?.name || "",
      editable: true,
    },
    {
      id: "image",
      label: t("Activity Image"),
      value: activityImage,
      editable: true,
      type: "image",
    },
    {
      id: "spec",
      label: t("Activity Type"),
      value: activity?.spec?.replace("lamp.", "") || "",
      editable: false,
    },
    {
      id: "description",
      label: t("Activity Description"),
      value: activityDesc || activity?.description || "",
      editable: true,
      type: "multiline",
    },
    {
      id: "study_name",
      label: t("Study Name"),
      value: activity?.study_name || "",
      editable: false,
    },
    {
      id: "groups",
      label: t("Groups"),
      value: selectedGroups,
      editable: true,
      type: "multiselect",
      options:
        studies
          .find((s) => s.id === selectedStudy)
          ?.gname.map((group) => ({
            value: group,
            label: group,
            disabled: false,
          })) || [],
    },
    {
      id: "id",
      label: t("Activity ID"),
      value: activity?.id || "",
      editable: false,
    },
    {
      id: "category",
      label: t("Customize which Tab this Activity appears in"),
      value: activity?.category || [],
      editable: true,
      type: "multiselect",
      options: [
        { value: "assess", label: t("Assess") },
        { value: "learn", label: t("Learn") },
        { value: "manage", label: t("Manage") },
        { value: "prevent", label: t("Portal") },
      ],
    },
    {
      id: "version",
      label: t("Current Version"),
      value: activity?.currentVersion?.name || "v1.0",
      editable: false,
    },
    {
      id: "creator",
      label: t("Creator"),
      value: creatorName || "",
      editable: false,
    },
    {
      id: "createdAt",
      label: t("Created At"),
      value: activity?.createdAt ? new Date(activity.createdAt).toLocaleString() : "",
      editable: false,
    },
  ]

  const additionalSettings = (
    <Box className={Viewitemsclasses.fieldContainer}>
      <Typography className={Viewitemsclasses.viewLabel}>{t("Participant Feed")}</Typography>
      <FormControlLabel
        control={
          <Switch
            checked={showInFeed}
            onChange={(e) => {
              setShowInFeed(e.target.checked)
              setEditedValues((prev) => ({
                ...prev,
                showInFeed: e.target.checked,
              }))
            }}
            disabled={!isEditing}
          />
        }
        label={t("Show this activity in participant feed.")}
      />
      <Divider className={Viewitemsclasses.viewDivider} />
      <Typography className={Viewitemsclasses.viewLabel}>{t("Streak Settings")}</Typography>
      <FormControlLabel
        control={
          <Switch
            checked={streakSettings.enabled}
            onChange={(e) => {
              const newSettings = {
                ...streakSettings,
                enabled: e.target.checked,
              }
              setStreakSettings(newSettings)
              setEditedValues((prev) => ({
                ...prev,
                streak: newSettings,
              }))
            }}
            disabled={!isEditing}
          />
        }
        label={t("Enable streak popup")}
      />
      {streakSettings.enabled && (
        <Box className={Viewitemsclasses.fieldContainer}>
          <TextField
            fullWidth
            className={Viewitemsclasses.viewInput}
            label={t("Streak Title")}
            value={streakSettings.title}
            onChange={(e) => {
              const newSettings = {
                ...streakSettings,
                title: e.target.value,
              }
              setStreakSettings(newSettings)
              setEditedValues((prev) => ({
                ...prev,
                streak: newSettings,
              }))
            }}
            disabled={!isEditing}
            variant="outlined"
            size="small"
          />
          <TextField
            fullWidth
            className={Viewitemsclasses.viewInput}
            multiline
            minRows={3}
            label={t("Streak Description")}
            value={streakSettings.description}
            onChange={(e) => {
              const newSettings = {
                ...streakSettings,
                description: e.target.value,
              }
              setStreakSettings(newSettings)
              setEditedValues((prev) => ({
                ...prev,
                streak: newSettings,
              }))
            }}
            disabled={!isEditing}
            variant="outlined"
            size="small"
          />
        </Box>
      )}
    </Box>
  )

  // Create tab content for settings
  const SettingsContent = () => {
    const [localSettings, setLocalSettings] = useState(editedValues.settings || {})
    const [localFBSettings, setLocalFBSettings] = useState(editedValues.settings || {})
    const [localFormula, setLocalFormula] = useState(editedValues.formula4Fields || "")
    const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)

    const handleSaveSettings = async () => {
      setEditedValues((prev) => ({
        ...prev,
        formula4Fields: localFormula,
        settings:
          editedValues.spec === "lamp.form_builder" || editedValues.spec === "lamp.mood_tracker"
            ? localFBSettings
            : localSettings,
      }))
      setHasUnsavedChanges(false)
      const updatedSettings = {
        settings:
          editedValues.spec === "lamp.form_builder" || editedValues.spec === "lamp.mood_tracker"
            ? localFBSettings
            : localSettings,
        formula4Fields: localFormula,
      }
      try {
        console.log("before calling update settings", updatedSettings, localFBSettings, localSettings)
        const result = await LAMP.Activity.update(activity.id, updatedSettings as any)
        await Service.updateMultipleKeys(
          "activities",
          {
            activities: [
              {
                id: activity.id,
                ...updatedSettings,
              },
            ],
          },
          Object.keys(updatedSettings),
          "id"
        )

        onSave({
          ...activity,
          ...updatedSettings,
        })
        if (result) {
          enqueueSnackbar(t("Settings saved."), {
            variant: "success",
          })
        }
      } catch (error) {
        console.error("Error updating activity settings:", error)
        enqueueSnackbar(t("An error occurred while updating the activity settings."), {
          variant: "error",
        })
      }
    }

    useEffect(() => {
      setLocalSettings(editedValues.settings || {})
      setLocalFBSettings(editedValues.settings || {})
      setLocalFormula(editedValues.formula4Fields || "")
      setHasUnsavedChanges(false)
    }, [editedValues.spec]) // Only update when spec changes to prevent loops

    return (
      <Box mt={3}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h6" gutterBottom>
            {t("Activity Settings")}
          </Typography>
          <Box>
            {hasUnsavedChanges && (
              <Typography variant="body2" color="error" style={{ marginRight: 16 }}>
                {t("You have unsaved changes")}
              </Typography>
            )}
            <Button
              variant="contained"
              color="primary"
              onClick={handleSaveSettings}
              disabled={!hasUnsavedChanges}
              // disabled={!hasUnsavedChanges || !isEditing}
            >
              {t("Save Settings")}
            </Button>
          </Box>
        </Box>
        {editedValues.spec === "lamp.form_builder" ? (
          <FormBuilder
            onChange={(formData) => {
              console.log("INSIDE THE DETAIL ITEM Form data changed:", formData)
              setLocalFormula(formData.formula)
              setLocalSettings(formData.fields)
              setLocalFBSettings(formData.fields)
              setHasUnsavedChanges(true)
            }}
            formFieldsProp={localFBSettings}
            formula={localFormula}
            // viewMode={!isEditing}
          />
        ) : editedValues.spec === "lamp.mood_tracker" ? (
          <MoodTrackerBuilder
            oldFields={localFBSettings}
            onChange={(formData) => {
              console.log("INSIDE THE DETAILITEM Form data changed:", formData)
              setLocalSettings(formData)
              setLocalFBSettings(formData)
              setHasUnsavedChanges(true)
            }}
          />
        ) : Object.keys(schemaListObj).includes(editedValues.spec) ? (
          <DynamicForm
            schema={schemaListObj[editedValues.spec]}
            initialData={{
              settings: localSettings,
              spec: editedValues.spec,
            }}
            onChange={(x) => {
              console.log("Settings updated locally:", x)
              setLocalSettings(x.settings || {})
              setHasUnsavedChanges(true)
            }}
            viewMode={!isEditing}
          />
        ) : (
          <Box className={classes.codeBlock}>
            <pre>{JSON.stringify(activity?.settings || {}, null, 2)}</pre>
          </Box>
        )}
      </Box>
    )
  }



  return (
    <React.Fragment>
      <ViewItems
        fields={fields}
        tabs={[
          {
            id: "settings",
            label: t("Settings"),
            content: <SettingsContent />,
          },
          {
            id: "activityGuide",
            label: t("Activity Guide"),
            content: <ActivityGuideContent />,
          },
          {
            id: "scoreInterpretation",
            label: t("Score Interpretation"),
            content: <ScoreInterpretationContent />,
          },
          {
            id: "schedule",
            label: t("Schedule"),
            content: <ScheduleContent />,
          },
          {
            id: "versionHistory",
            label: t("Version History"),
            content: <VersionHistoryContent />,
          },
        ]}
        isEditing={isEditing}
        onSave={handleSave}
        onEdit={() => console.log("Edit clicked")}
        editedValues={editedValues}
        setEditedValues={setEditedValues}
        loading={loading}
        submissionInfo={getSubmissionInfo()}
        additionalContent={additionalSettings}
      />

      {/* Media Preview Dialog */}
      <Dialog
        open={previewDialogOpen}
        onClose={() => setPreviewDialogOpen(false)}
        maxWidth="lg"
        fullWidth
        className={classes.previewDialog}
      >
        <DialogTitle>{selectedMedia?.type === "video" ? t("Video Preview") : t("Audio Preview")}</DialogTitle>
        <DialogContent>
          {selectedMedia?.type === "video" ? (
            <video className={classes.previewVideo} controls autoPlay>
              <source src={selectedMedia.src} type={selectedMedia.mimeType} />
              {t("Your browser does not support the video tag.")}
            </video>
          ) : (
            <audio controls autoPlay style={{ width: "100%" }}>
              <source src={selectedMedia?.src} type={selectedMedia?.mimeType} />
              {t("Your browser does not support the audio element.")}
            </audio>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setPreviewDialogOpen(false)} color="primary">
            {t("Close")}
          </Button>
          <Button
            color="primary"
            onClick={() => {
              if (selectedMedia) {
                const link = document.createElement("a")
                link.href = selectedMedia.src
                const fileType = selectedMedia.mimeType.split("/")[1]
                link.download = `${selectedMedia.type}_guide_${activity.id}_${new Date().getTime()}.${fileType}`
                document.body.appendChild(link)
                link.click()
                document.body.removeChild(link)
              }
            }}
          >
            {t("Download")}
          </Button>
        </DialogActions>
      </Dialog>
    </React.Fragment>
  )
}

export default ActivityDetailItem
