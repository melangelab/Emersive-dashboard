const AsyncStatsContent: React.FC<{
  selectedTab: any
  study: any
  participant: any
  classes: any
}> = ({ selectedTab, study, participant, classes }) => {
  const [items, setItems] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [expandedIndex, setExpandedIndex] = useState<number | null>(null)
  const [startDate, setStartDate] = useState<Date | null>(
    new Date(new Date().setDate(new Date().getDate() - 7)) // Default to 7 days ago
  )
  const [endDate, setEndDate] = useState<Date | null>(new Date()) // Default to today
  const [dateRangeEnabled, setDateRangeEnabled] = useState<boolean>(false)

  useEffect(() => {
    const fetchStats = async () => {
      setLoading(true)
      try {
        const authString = LAMP.Auth._auth.id + ":" + LAMP.Auth._auth.password
        let newItems: any[] = []
        const endpoint = dateRangeEnabled
          ? `participant/mode/6?from_date=${startDate?.getTime()}&to_date=${endDate?.getTime()}`
          : "participant/mode/5"
        const result = await fetchResult(authString, study.id, endpoint, "study")
        const participantData = result.participants?.find((p) => p.id === participant.id)
        console.log("participantData", participantData, endpoint)
        if (selectedTab.tab === "assessments") {
          newItems = study.activities?.filter((a) => a.category?.includes("assess")) || []
        } else if (selectedTab.tab === "activities") {
          if (dateRangeEnabled && participantData?.activity_events) {
            // When date range is enabled, use the activity events in the date range
            const activityMap = new Map()
            ;(study.activities || []).forEach((activity) => {
              activityMap.set(activity.id, { ...activity, events: [] })
            })

            // Group events by activity
            participantData.activity_events.forEach((event) => {
              if (activityMap.has(event.activity)) {
                const activity = activityMap.get(event.activity)
                activity.events.push({
                  ...event,
                  timestamp: new Date(event.timestamp).toLocaleString(),
                })
              }
            })

            newItems = Array.from(activityMap.values())
          } else {
            newItems = (study.activities || []).map((activity) => {
              const activityEvent = participantData?.last_activity_events?.find((e) => e.activity_id === activity.id)
              return {
                ...activity,
                lastEvent: activityEvent?.last_event
                  ? {
                      ...activityEvent.last_event,
                      timestamp: new Date(activityEvent.last_event.timestamp).toLocaleString(),
                    }
                  : null,
              }
            })
          }
        } else if (selectedTab.tab === "sensors") {
          if (dateRangeEnabled && participantData?.sensor_events) {
            // When date range is enabled, use the sensor events in the date range
            const sensorMap = new Map()
            ;(study.sensors || []).forEach((sensor) => {
              sensorMap.set(sensor.spec, { ...sensor, events: [] })
            })

            // Group events by sensor
            participantData.sensor_events.forEach((event) => {
              if (sensorMap.has(event.sensor)) {
                const sensor = sensorMap.get(event.sensor)
                sensor.events.push({
                  ...event,
                  timestamp: new Date(event.timestamp).toLocaleString(),
                })
              }
            })

            newItems = Array.from(sensorMap.values())
          } else {
            newItems = (study.sensors || []).map((sensor) => {
              const sensorEvent = participantData?.last_sensor_events?.find((s) => s.sensor_spec === sensor.spec)
              return {
                ...sensor,
                lastEvent: sensorEvent?.last_event
                  ? {
                      ...sensorEvent.last_event,
                      timestamp: new Date(sensorEvent.last_event.timestamp).toLocaleString(),
                    }
                  : null,
              }
            })
          }
        }
        setItems(newItems)
      } catch (err) {
        console.error("Failed to fetch stats:", err)
        setItems([])
      } finally {
        setLoading(false)
      }
    }

    fetchStats()
  }, [selectedTab, study, participant, dateRangeEnabled, startDate, endDate])

  const handleStartDateChange = (date: Date | null) => {
    setStartDate(date)
  }

  const handleEndDateChange = (date: Date | null) => {
    setEndDate(date)
  }
  
  // Helper function to render sensor data
  const renderSensorData = (data: any) => {
    if (!data) return <Typography variant="body2">No data available</Typography>;
    
    if (typeof data !== 'object') {
      return <Typography variant="body2">{String(data)}</Typography>;
    }
    
    return (
      <Box pl={1}>
        {Object.entries(data).map(([key, value]) => (
          <Box key={key} mb={1}>
            <Typography variant="body2">
              <strong>{key}:</strong> {
                typeof value === 'object' && value !== null
                  ? JSON.stringify(value)
                  : String(value)
              }
            </Typography>
          </Box>
        ))}
      </Box>
    );
  };

  if (loading) {
    return <Typography className={classes.groupName}>Loading...</Typography>
  }

  if (items.length === 0) {
    return <Typography className={classes.groupName}>{`No ${selectedTab.tab} present at this moment.`}</Typography>
  }

  console.log("items", items)
  return (
    <Box className={classes.groupList}>
      <Box mb={2} display="flex" flexDirection="row" alignItems="center">
        <MuiPickersUtilsProvider utils={DateFnsUtils}>
          <Box display="flex" alignItems="center" flexWrap="wrap">
            <Box mr={2} mb={1}>
              <KeyboardDatePicker
                disabled={!dateRangeEnabled}
                margin="normal"
                id="start-date-picker"
                label="Start Date"
                format="MM/dd/yyyy"
                value={startDate}
                onChange={handleStartDateChange}
                KeyboardButtonProps={{
                  "aria-label": "change start date",
                }}
                style={{ width: 180 }}
              />
            </Box>
            <Box mr={2} mb={1}>
              <KeyboardDatePicker
                disabled={!dateRangeEnabled}
                margin="normal"
                id="end-date-picker"
                label="End Date"
                format="MM/dd/yyyy"
                value={endDate}
                onChange={handleEndDateChange}
                KeyboardButtonProps={{
                  "aria-label": "change end date",
                }}
                style={{ width: 180 }}
              />
            </Box>
            <Box mb={1} display="flex" alignItems="center">
              <Box
                component="label"
                mr={1}
              >
                <Typography variant="body2">Enable Date Range</Typography>
              </Box>
              <input
                id="date-range-toggle"
                type="checkbox"
                checked={dateRangeEnabled}
                onChange={(e) => setDateRangeEnabled(e.target.checked)}
              />
            </Box>
          </Box>
        </MuiPickersUtilsProvider>
      </Box>
      <Divider style={{ marginBottom: 16 }} />
      {items.map((item, index) => (
        <Box key={index} className={classes.groupItem}>
          <Typography className={classes.groupName}>{item.name}</Typography>
          <Typography className={classes.groupDesc}>{item.spec}</Typography>
          {dateRangeEnabled && item.events ? (
            <Box mt={1}>
              <Box display="flex" alignItems="center">
                <Typography variant="subtitle2" color="textSecondary">
                  Events: {item.events.length}
                </Typography>
                <IconButton
                  size="small"
                  onClick={() => setExpandedIndex(expandedIndex === index ? null : index)}
                  style={{ marginLeft: 8 }}
                >
                  {expandedIndex === index ? <ExpandLessIcon fontSize="small" /> : <ExpandMoreIcon fontSize="small" />}
                </IconButton>
              </Box>
              <Collapse in={expandedIndex === index} timeout="auto" unmountOnExit>
                <Box mt={1} pl={2} borderLeft="3px solid #ccc">
                  {item.events.length > 0 ? (
                    item.events.map((event: any, eventIdx: number) => (
                      <Box key={eventIdx} mb={2} pb={1} borderBottom="1px dashed #eee">
                        <Typography variant="body2" color="textPrimary">
                          <strong>Timestamp:</strong> {event.timestamp}
                        </Typography>
                        {selectedTab.tab === "activities" && event.temporal_slices && (
                          <Box mt={1} pl={2}>
                            {event.temporal_slices.map((slice: any, sliceIdx: number) => (
                              <Box key={sliceIdx} mb={1}>
                                <Typography variant="body2" color="textPrimary">
                                  <strong>Item:</strong> {slice.item}
                                </Typography>
                                <Typography variant="body2" color="textSecondary">
                                  <strong>Value:</strong> {slice.value || "N/A"}
                                </Typography>
                                {Object.keys(slice.emotions || {}).length > 0 && (
                                  <Typography variant="body2" color="textSecondary">
                                    <strong>Emotions:</strong>{" "}
                                    {Object.entries(slice.emotions)
                                      .map(([k, v]) => `${k}: ${v}`)
                                      .join(", ")}
                                  </Typography>
                                )}
                                <Typography variant="body2" color="textSecondary">
                                  <strong>Duration:</strong> {slice.duration} ms
                                </Typography>
                              </Box>
                            ))}
                          </Box>
                        )}
                        {selectedTab.tab === "sensors" && (
                          <Box mt={1}>
                            <Typography variant="body2" color="textSecondary">
                              <strong>Sensor Data:</strong>
                            </Typography>
                            {renderSensorData(event.data)}
                          </Box>
                        )}
                      </Box>
                    ))
                  ) : (
                    <Typography variant="body2" color="textSecondary">
                      No events found in the selected date range.
                    </Typography>
                  )}
                </Box>
              </Collapse>
            </Box>
          ) : (
            item.lastEvent && (
              <Box mt={1}>
                <Box display="flex" alignItems="center">
                  <Typography variant="subtitle2" color="textSecondary">
                    Last Event: {item.lastEvent.timestamp}
                  </Typography>
                  <IconButton
                    size="small"
                    onClick={() => setExpandedIndex(expandedIndex === index ? null : index)}
                    style={{ marginLeft: 8 }}
                  >
                    {expandedIndex === index ? (
                      <ExpandLessIcon fontSize="small" />
                    ) : (
                      <ExpandMoreIcon fontSize="small" />
                    )}
                  </IconButton>
                </Box>
                <Collapse in={expandedIndex === index} timeout="auto" unmountOnExit>
                  {selectedTab.tab === "activities" && item.lastEvent.temporal_slices && (
                    <Box mt={1} pl={2} borderLeft="3px solid #ccc">
                      {item.lastEvent.temporal_slices.map((slice: any, idx: number) => (
                        <Box key={idx} mb={1}>
                          <Typography variant="body2" color="textPrimary">
                            <strong>Item:</strong> {slice.item}
                          </Typography>
                          <Typography variant="body2" color="textSecondary">
                            <strong>Value:</strong> {slice.value || "N/A"}
                          </Typography>
                          {Object.keys(slice.emotions || {}).length > 0 && (
                            <Typography variant="body2" color="textSecondary">
                              <strong>Emotions:</strong>{" "}
                              {Object.entries(slice.emotions)
                                .map(([k, v]) => `${k}: ${v}`)
                                .join(", ")}
                            </Typography>
                          )}
                          <Typography variant="body2" color="textSecondary">
                            <strong>Duration:</strong> {slice.duration} ms
                          </Typography>
                        </Box>
                      ))}
                    </Box>
                  )}
                  {selectedTab.tab === "sensors" && item.lastEvent.data && (
                    <Box mt={1} pl={2} borderLeft="3px solid #ccc">
                      <Typography variant="body2" color="textPrimary">
                        <strong>Sensor Data:</strong>
                      </Typography>
                      {renderSensorData(item.lastEvent.data)}
                    </Box>
                  )}
                </Collapse>
              </Box>
            )
          )}
        </Box>
      ))}
    </Box>
  )
}